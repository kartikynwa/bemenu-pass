#!/usr/bin/env bash

# bemenu-pass
# (c) 2015 Rasmus Steinke <rasi@xssn.at>
basecommand="$0"

# set default settings
_bemenu () {
	bemenu -l 10 -i "$@"
}

_pwgen () {
	pwgen -y "$@"
}

_image_viewer () {
	feh -
}

config_dir=${XDG_CONFIG_HOME:-$HOME/.config}
cache_dir=${XDG_CACHE_HOME:-$HOME/.cache}

# We expect to find these fields in pass(1)'s output
URL_field='url'
USERNAME_field='user'
AUTOTYPE_field='autotype'
OTPmethod_field='otp_method'

default_autotype="user :tab pass"
delay=2
wait=0.2
default_do='menu' # menu, copyPass, typeUser, typePass, copyUser, copyUrl, viewEntry, typeMenu, actionMenu, copyMenu, openUrl
auto_enter='false'
notify='false'
help_color=""
clip=primary
clip_clear=45
default_user="${BEMENU_PASS_DEFAULT_USER-$(whoami)}"
default_user2=john_doe
password_length=12
fix_layout=false

# Safe permissions
umask 077

has_qrencode() {
	command -v qrencode >/dev/null 2>&1
}

listgpg () {
	mapfile -d '' pw_list < <(find -L . -name '*.gpg' -print0)
	pw_list=("${pw_list[@]#./}")
	printf '%s\n' "${pw_list[@]}" | sort -n
}

# get all password files and output as newline-delimited text
list_passwords() {
	cd "${root}" || exit
	mapfile -t pw_list < <(listgpg)
	printf '%s\n' "${pw_list[@]%.gpg}" | sort -n
}

doClip () {
	case "$clip" in
		"primary") wl-copy -p;;
		"clipboard") wl-copy;;
		"both") wl-copy -p; wl-copy -o | wl-copy;;
	esac
}

checkIfPass () {
	printf '%s\n' "${root}: $selected_password" >| "$cache_dir/bemenu-pass/last_used"
}


autopass () {
	x_repeat_enabled=$(xset q | awk '/auto repeat:/ {print $3}')
	xset r off

	rm -f "$cache_dir/bemenu-pass/last_used"
	printf '%s\n' "${root}: $selected_password" > "$cache_dir/bemenu-pass/last_used"
	for word in ${stuff["$AUTOTYPE_field"]}; do
		case "$word" in
			":tab") sleep "${wait}"; wtype -k tab;;
			":space") sleep "${wait}"; wtype -k space;;
			":delay") sleep "${delay}";;
			":enter") sleep "${wait}"; wtype -k return;;
			":otp") sleep "${wait}"; wtype -- "$(generateOTP)";;
			"pass") sleep "${wait}"; wtype -- "${password}";;
			"path") sleep "${wait}"; wtype -- "${selected_password}";;
			*) sleep "${wait}"; wtype -- "${stuff[${word}]}";;
		esac
	done

	if [[ ${auto_enter} == "true" ]]; then
		sleep "${wait}"; wtype -k return
	fi

	xset r "$x_repeat_enabled"
	unset x_repeat_enabled
	clearUp
}

generateQrCode() {
	has_qrencode

	if [[ $? -eq "1" ]]; then
		printf '%s\n' "qrencode not found" | _bemenu
		exit_code=$?
		if [[ $exit_code -eq "1" ]]; then
			exit
		else
			"${basecommand}"
		fi
	fi

	checkIfPass
	pass "$selected_password" | head -n 1 | qrencode -d 300 -v 8 -l H -o - | _image_viewer
	if [[ $? -eq "1" ]]; then
		printf '%s\n' "" | _bemenu -mesg "Image viewer not defined or cannot read from pipe"
		exit_value=$?
		if [[ $exit_value -eq "1" ]]; then
			exit
		else
			"${basecommand}"
		fi
	fi
	clearUp
}

openURL () {
	checkIfPass
	$BROWSER "$(PASSWORD_STORE_DIR="${root}" pass "$selected_password" | grep "${URL_field}: " | gawk '{sub(/:/,"")}{print $2}1' | head -1)"; exit;
	clearUp
}

typeUser () {
	checkIfPass

	x_repeat_enabled=$(xset q | awk '/auto repeat:/ {print $3}')
	xset r off

	wtype -- "${stuff[${USERNAME_field}]}"

	xset r "$x_repeat_enabled"
	unset x_repeat_enabled

	clearUp
}

typePass () {
	checkIfPass

	x_repeat_enabled=$(xset q | awk '/auto repeat:/ {print $3}')
	xset r off

	wtype -- "${password}"

	if [[ $notify == "true" ]]; then
		if [[ "${stuff[notify]}" == "false" ]]; then
			:
		else
			notify-send "bemenu-pass" "finished typing password";
		fi
	elif [[ $notify == "false" ]]; then
		if [[ "${stuff[notify]}" == "true" ]]; then
			notify-send "bemenu-pass" "finished typing password";
		else
			:
		fi
	fi

	xset r "$x_repeat_enabled"
	unset x_repeat_enabled
	clearUp
}

typeField () {
	checkIfPass
	local to_type

	x_repeat_enabled=$(xset q | awk '/auto repeat:/ {print $3}')
	xset r off

	case $typefield in
		"OTP") to_type="$(generateOTP)" ;;
		*) to_type="${stuff[${typefield}]}" ;;
	esac

	wtype -- "$to_type"

	xset r "$x_repeat_enabled"
	unset x_repeat_enabled
	unset to_type

	clearUp
}

generateOTP () {
	checkIfPass

	# First, we check if there is a non-conventional OTP command in the pass file
	if PASSWORD_STORE_DIR="${root}" pass "$selected_password" | grep -q "${OTPmethod_field}: "; then
		# We execute the commands after otp_method: AS-IS
		bash -c "$(PASSWORD_STORE_DIR="${root}" pass "$selected_password" | grep "${OTPmethod_field}: " | cut -d' ' -f2-)"
	else
		# If there is no method defined, fallback to pass-otp
		PASSWORD_STORE_DIR="${root}" pass otp "$selected_password"
	fi

	clearUp
}

copyUser () {
	checkIfPass
	printf '%s' "${stuff[${USERNAME_field}]}" | doClip
	clearUp
}

copyField () {
	checkIfPass
	printf '%s' "${stuff[${copyfield}]}" | doClip
	clearUp
}

copyURL () {
	checkIfPass
	printf '%s' "${stuff[${URL_field}]}" | doClip
	clearUp
}

copyPass () {
	checkIfPass
	printf '%s' "$password" | doClip
	if [[ $notify == "true" ]]; then
		notify-send "bemenu-pass" "Copied Password\\nClearing in $clip_clear seconds"
	fi

	if [[ $notify == "true" ]]; then
		(sleep $clip_clear; printf '%s' "" | xclip; printf '%s' "" | xclip -selection clipboard | notify-send "bemenu-pass" "Clipboard cleared") &
	elif [[ $notify == "false" ]]; then
		(sleep $clip_clear; printf '%s' "" | xclip; printf '%s' "" | xclip -selection clipboard) &
	fi
}

viewEntry () {
	checkIfPass
	showEntry "${selected_password}"
}

generatePass () {
	askmenu_content=(
		"Yes"
		"No"
	)

	askGenMenu=$(printf '%s\n' "${askmenu_content[@]}" | _bemenu -p "Generate new Password for ${selected_password}? > ")
	askgen_exit=$?

	if [[ $askgen_exit -eq 1 ]]; then
		exit
	fi
	if [[ $askGenMenu == "Yes" ]]; then
		true
	elif [[ $askGenMenu == "No" ]]; then
		actionMenu
	fi

	checkIfPass

	symbols_content=(
		"0  Cancel"
		"1  Yes"
		"2  No"
	)

	symbols=$(printf '%s\n' "${symbols_content[@]}" | _bemenu -p "Use Symbols? > ")
	symbols_val=$?

	if [[ $symbols_val -eq 1 ]]; then
		exit
	fi
	if [[ $symbols == "0  Cancel" ]]; then
		mainMenu;
	elif [[ $symbols == "1  Yes" ]]; then
		symbols="";
	elif [[ $symbols == "2  No" ]]; then
		symbols="-n";
	fi

	HELP="<span color='$help_color'>Enter Number or hit Enter to use default length</span>"
	length=$(printf '%s' "" | _bemenu -mesg "${HELP}" -p "Password length? (Default: ${password_length}) > ")
	length_exit=$?

	if [[ $length_exit -eq 1 ]]; then
		exit
	fi
	if [[ $length == "" ]]; then
		PASSWORD_STORE_DIR="${root}" pass generate ${symbols} -i "$selected_password" "${password_length}" > /dev/null;
	else
		PASSWORD_STORE_DIR="${root}" pass generate ${symbols} -i "$selected_password" "${length}" > /dev/null;
	fi
}

# main Menu
mainMenu () {
	unset selected_password

	args+=( -p "> " )

	selected_password="$(list_passwords 2>/dev/null | _bemenu "${args[@]}")"

	bemenu_exit=$?
	if [[ $bemenu_exit -eq 1 ]]; then
		exit
	fi

	mapfile -t password_temp < <(PASSWORD_STORE_DIR="${root}" pass show "$selected_password")
	password=${password_temp[0]}

	if [[ ${password} == "#FILE="* ]]; then
		pass_file="${password#*=}"
		mapfile -t password_temp2 < <(PASSWORD_STORE_DIR="${root}" pass show "${pass_file}")
		password=${password_temp2[0]}
	fi

	fields=$(printf '%s\n' "${password_temp[@]:1}" | awk '$1 ~ /:$/ || /otpauth:\/\// {$1=$1;print}')
	declare -A stuff
	stuff["pass"]=${password}

	if [[ -n $fields ]]; then
		while read -r LINE; do
			unset _id _val
			case "$LINE" in
				"otpauth://"*|"${OTPmethod_field}"*)
					_id="OTP"
					_val=""
					;;
				*)
					_id="${LINE%%: *}"
					_val="${LINE#* }"
					;;
			esac

			if [[ -n "$_id" ]]; then
				stuff["${_id}"]=${_val}
			fi
		done < <(printf '%s\n' "${fields}")

		if test "${stuff['autotype']+autotype}"; then
			:
		else
			stuff["autotype"]="${USERNAME_field} :tab pass"
		fi
	fi

	if [[ -z "${stuff["${AUTOTYPE_field}"]}" ]]; then
		if [[ -n $default_autotype ]]; then
			stuff["${AUTOTYPE_field}"]="${default_autotype}"
		fi
	fi
	if [[ -z "${stuff["${USERNAME_field}"]}" ]]; then
		if [[ -n $default_user ]]; then
			if [[ "$default_user" == ":filename" ]]; then
				stuff["${USERNAME_field}"]="$(basename "$selected_password")"
			else
				stuff["${USERNAME_field}"]="${default_user}"
			fi
		fi
	fi
	pass_content="$(for key in "${!stuff[@]}"; do printf '%s\n' "${key}: ${stuff[$key]}"; done)"

	# actions based on keypresses
	# The exit code for -kb-custom-X is X+9.
	if [[ $bemenu_exit -eq 0 ]]; then
		typeMenu
	fi
	clearUp
}


clearUp () {
	password=''
	selected_password=''
	unset stuff
	unset password
	unset selected_password
	unset password_temp
	unset stuff
}

typeMenu () {
	if [[ -n $default_do ]]; then
		if [[ $default_do == "menu" ]]; then
			checkIfPass
			local -a keys=("${!stuff[@]}")
			keys=("${keys[@]/$AUTOTYPE_field}")
			typefield=$({ printf '%s' "${AUTOTYPE_field}" ; printf '%s\n' "${keys[@]}" | sort; } | _bemenu  -p "Choose Field to type > ")
			typefield_exit=$?
			if [[ $typefield_exit -eq 1 ]]; then
				exit
			fi
			case "$typefield" in
				'') exit;;
				'pass') typePass;;
				"${AUTOTYPE_field}") autopass;;
				*) typeField
			esac
			clearUp
		elif [[ $default_do == "${AUTOTYPE_field}" ]]; then
			autopass
		else
			${default_do}
		fi
	fi
}

help_msg () {
	cat <<'EOF'
	Usage:
	bemenu-pass [command]

	Commands:
	--insert         insert new entry to password store
	--root           set custom root directories (colon separated)
	--last-used      highlight last used item
	--show-last      show details of last used Entry
	--bmarks         start in bookmarks mode

	bemenu-pass version 1.5.3
EOF
}

get_config_file () {
	configs=("$BEMENU_PASS_CONFIG"
		"$config_dir/bemenu-pass/config"
		"/etc/bemenu-pass.conf")

	# return the first config file with a valid path
	for config in "${configs[@]}"; do
		# '-n' is needed in case BEMENU_PASS_CONFIG is not set
		if [[ -n "${config}" && -f "${config}" ]]; then
			printf "%s" "$config"
			return
		fi
	done
}

main () {
	# load config file
	config_file="$(get_config_file)"
	[[ -n "$config_file" ]] && source "$config_file"

	# create tmp dir
	if [[ ! -d "$cache_dir/bemenu-pass" ]]; then
		mkdir -p "$cache_dir/bemenu-pass"
	fi

	# fix keyboard layout if enabled in config
	if [[ $fix_layout == "true" ]]; then
		layout_cmd
	fi

	# set help color
	if [[ $help_color == "" ]]; then
		help_color=$(rofi -dump-xresources | grep 'rofi.color.normal' | gawk -F ',' '/,/{gsub(/ /, "", $2); print $2}')
	fi

	# check for BROWSER variable, use xdg-open as fallback
	if [[ -z $BROWSER ]]; then
		export BROWSER=xdg-open
	fi

	# check if alternative root directory was given on commandline
	if [[ -r "$cache_dir/bemenu-pass/last_used" ]] && [[ $1 == "--last-used" || $1 == "--show-last" ]]; then
		roots=("$(awk -F ': ' '{ print $1 }' "$cache_dir/bemenu-pass/last_used")")
	elif [[ -n "$2" && "$1" == "--root" ]]; then
		custom_root=true; IFS=: read -r -a roots <<< "$2"
	elif [[ -n $root ]]; then
		custom_root=true; IFS=: read -r -a roots <<< "${root}"
	elif [[ -n ${PASSWORD_STORE_DIR} ]]; then
		roots=("${PASSWORD_STORE_DIR}")
	else
		roots=("$HOME/.password-store")
	fi
	roots_index=0
	roots_length=${#roots[@]}
	export root=${roots[$roots_index]}
	export PASSWORD_STORE_DIR="${root}"
	case $1 in
		--root)
			mainMenu
			;;
		--help)
			help_msg
			;;
		*)
			mainMenu
			;;
	esac
}

main "$@"
